排序
插入排序
		直接插入排序 [O(n^2)最好]
				最好（初始状态正序：比较n-1次，移动2(n-1)次）
				最差（初始状态逆序：比较(n+2)(n-1)/2次，移动(n+4)(n-1)/2次）
				平均（O(n^2)）

		希尔排序 [O(nlog₂n)] 循环log2n趟  与插入排序一样
				最好（初始状态正序：O(n)）
				最差（初始状态逆序 O(nlog₂n)）

交换排序
		冒泡排序
				最好（初始状态正序：比较n-1次，交换0次   O(n)）
				最差（初始状态逆序：比较和交换各n(n-1)/2次   O(n^2)）
				平均（O(n^2)）

		快速排序
				最好（数据为AVL树状态    O(log₂n)）
				最差（初始状态有序    O(n^2)）
选择排序
		直接选择排序 
				比较次数：n(n-1)/2

		锦标赛排序 
		堆排序O(nlog₂n)：建堆（大根堆、小根堆），然后弹出根结点元素，再由最后一个元素补到根节点后，再次由上滤或下滤建堆，再弹出根节点，以此类推，最后得到有顺序的根节点的元素为排列好的
							首先：建立初始堆：按层序把元素建立成树
				建大根堆过程：找到最后一个元素的父节点，从此处开始，层序顺序向前直到1，都进行堆调整
				建小根堆过程：同上，但元素大小关系颠倒
				弹出根，然后最后一个结点补充到根，再次重复建堆，直到最后堆排序完成

归并排序 O(nlog₂n)
基数排序 O(d*(n+r)) r：关键字基数，d：代表数字位数，n: 关键字的个数
计数排序 Ο(n+k)（其中k是整数的范围），
桶排序 O(n+m*F(n/m))：申请桶的个数n= (Max-Min)/间隔 + 1 


哪些排序一趟能让至少一个元素在最终位置	  
插入排序 归并排序 希尔 基数—一趟不可以    
交换排序（冒泡排序、快速排序）选择排序（直接选择排序、堆排序）——一趟可以    

排序与初始状态：
算法复杂度与初始状态无关：选择、堆、归并
比较次数与初始状态无关：选择，折半插入、归并
移动次数与初始状态无关：归并
排列趟数与初始状态无关：插入、选择

初始状态基本有序，用直接插入效率最高
平均情况下快速排序最好

排序基本操作：关键字的比较 和 记录的移动
外排序操作：生成有序归并段->归并
